#!/usr/bin/env python3
"""
Host Code Generator for TT-Metal Kernel Generator
Generates complete host code and CMakeLists.txt for generated kernels.
"""

from pathlib import Path
from typing import Dict, Optional
import logging
from groq import Groq
from config import OPERATIONS, CORE_MODES, OPENAI_TEMPERATURE, OPENAI_MAX_TOKENS, OPENAI_MODEL_DEFAULT

logger = logging.getLogger(__name__)


class HostCodeGenerator:
    """Generates host code and build files for TT-Metal kernels"""

    def __init__(self, openai_client: Groq):
        self.client = openai_client

    def generate_host_code(
        self, operation: str, core_mode: str, kernels: Dict[str, str], system_prompt: str, model: str = None
    ) -> str:
        """Generate complete host code for the kernels"""

        if model is None:
            model = OPENAI_MODEL_DEFAULT

        op_config = OPERATIONS[operation]
        core_config = CORE_MODES[core_mode]

        # Determine kernel file names based on core mode
        if core_mode == "single":
            reader_filename = "reader_binary_1_tile.cpp"
            writer_filename = "writer_1_tile.cpp"
        else:
            reader_filename = "reader_binary_tiles_partitioned.cpp"
            writer_filename = "writer_tiles_partitioned.cpp"

        host_prompt = f"""Generate complete TT-Metal host code for {op_config['description']} using {core_config['description']}.

## Requirements:

### Kernel Files:
- Compute: kernels/compute/{op_config['kernel_name']}.cpp
- Reader: kernels/dataflow/{reader_filename}
- Writer: kernels/dataflow/{writer_filename}

### Host Code Features:
1. Complete main() function with argument parsing
2. Device initialization and mesh setup
3. Input data generation (random bfloat16 matrices)
4. DRAM buffer creation and data transfer
5. Circular buffer configuration
6. Kernel compilation and execution
7. Result validation against golden reference
8. Proper error handling and cleanup
9. Performance timing and reporting

### Code Structure:
- Include all necessary headers
- Implement golden reference function for validation
- Use proper TT-Metal APIs (distributed::MeshDevice, etc.)
- Handle both single-core and multi-core cases appropriately
- Add comprehensive logging and error messages

### For Single-Core:
- Simple core grid (1x1)
- Basic buffer management
- Sequential execution

### For Multi-Core:
- Use split_work_to_cores() for work distribution
- Proper SPMD parallelization
- Multi-core buffer management
- Core grid optimization

Generate only the complete .cpp host code file."""

        try:
            response = self.client.chat.completions.create(
                model=model,
                messages=[{"role": "system", "content": system_prompt}, {"role": "user", "content": host_prompt}],
                temperature=OPENAI_TEMPERATURE,
                max_tokens=OPENAI_MAX_TOKENS,
            )

            # Groq/OpenAI-compatible response handling
            host_code = getattr(response.choices[0].message, "content", response.choices[0].message.content)

            # Extract code from markdown if present
            if "```cpp" in host_code:
                host_code = host_code.split("```cpp")[1].split("```")[0].strip()
            elif "```" in host_code:
                host_code = host_code.split("```")[1].split("```")[0].strip()

            logger.info(f"Generated host code ({len(host_code)} characters)")
            return host_code

        except Exception as e:
            logger.error(f"Error generating host code: {e}")
            return self._generate_fallback_host_code(operation, core_mode)

    def generate_cmake_file(self, operation: str, core_mode: str, project_name: Optional[str] = None) -> str:
        """Generate CMakeLists.txt for the project"""

        if not project_name:
            project_name = f"{operation}_{core_mode}_example"

        op_config = OPERATIONS[operation]
        core_config = CORE_MODES[core_mode]

        # Determine kernel file names (using absolute paths from TT_METAL_HOME)
        if core_mode == "single":
            reader_kernel = f"tt_metal/programming_examples/{project_name}/kernels/dataflow/reader_binary_1_tile.cpp"
            writer_kernel = f"tt_metal/programming_examples/{project_name}/kernels/dataflow/writer_1_tile.cpp"
        else:
            reader_kernel = (
                f"tt_metal/programming_examples/{project_name}/kernels/dataflow/reader_binary_tiles_partitioned.cpp"
            )
            writer_kernel = (
                f"tt_metal/programming_examples/{project_name}/kernels/dataflow/writer_tiles_partitioned.cpp"
            )

        compute_kernel = f"tt_metal/programming_examples/{project_name}/kernels/compute/{op_config['kernel_name']}.cpp"

        cmake_content = f"""# CMakeLists.txt for {project_name}
# Generated by TT-Metal Kernel Generator

cmake_minimum_required(VERSION 3.22...3.30)
project({project_name})

add_executable({project_name})
target_sources({project_name} PRIVATE {project_name}.cpp)

if(NOT TARGET TT::Metalium)
    find_package(TT-Metalium REQUIRED)
endif()
target_link_libraries({project_name} PUBLIC TT::Metalium)
"""

        logger.info("Generated CMakeLists.txt")
        return cmake_content

    def _generate_fallback_host_code(self, operation: str, core_mode: str) -> str:
        """Generate a minimal fallback host code if LLM generation fails"""

        op_config = OPERATIONS[operation]

        return f"""// Fallback host code for {op_config['description']} ({core_mode}-core)
// Generated by TT-Metal Kernel Generator

#include <tt-metalium/host_api.hpp>
#include <tt-metalium/constants.hpp>
#include <tt-metalium/bfloat16.hpp>
#include <tt-metalium/distributed.hpp>
#include <iostream>
#include <vector>
#include <random>

using namespace tt;
using namespace tt::tt_metal;
using namespace tt::constants;

int main(int argc, char* argv[]) {{
    std::cout << "TT-Metal {op_config['description']} example ({core_mode}-core)\\n";
    std::cout << "This is a fallback implementation.\\n";
    std::cout << "Please check the generated kernels and implement the host code manually.\\n";

    // TODO: Implement complete host code
    // 1. Initialize device and mesh
    // 2. Create input/output buffers
    // 3. Configure circular buffers
    // 4. Compile and run kernels
    // 5. Validate results

    return 0;
}}
"""
